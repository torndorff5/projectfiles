A .BYT 'A'
B .BYT 'B'
C .BYT 'C'
E .BYT 'E'
F .BYT 'F'
H .BYT 'H'
I .BYT 'I'
K .BYT 'K'
L .BYT 'L'
N .BYT 'N'
O .BYT 'O'
R .BYT 'R'
S .BYT 'S'
T .BYT 'T'
V .BYT 'V'
W .BYT 'W'
X .BYT 'X'
Y .BYT 'Y'
NL .BYT 10
COM .BYT ','
SACE .BYT 32
INPUT .INT 0
ONE .INT 1
ZERO .INT 0
ARRAY .INT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
SIZE .INT 120
CNT .INT 0
ITER .INT 0


TRP 5
STR R3, INPUT
; TEST FOR OVERFLOW
MOV R5, SP      ; Test for overflow
ADI R5, -12     ; Allocate for 1 int parameters plus RA and PFP AND RV
CMP R5, SL
BLT R5, OVERFLOW
; CREATE ACTIVATION RECORD FOR FIB
MOV R3, FP  ; SAVE FOR PFP
MOV FP, SP  ; FP = SP
ADI SP, -4  ; MOVE SP UP TO ADD RA
STR R3, SP  ; PUT PFP AT LOCATION FP - 4
ADI SP, -4  ; MOVE SP TO PASS A INPUT
LDR R3, INPUT
STR R3, SP  ; PUT INPUT INT AT SP (FP - 8)
ADI SP, -4  ; MOVE SP UP TO LEAVE ROOM FOR RETURN VALUE (FP - 12)
MOV R1, PC  ; PUT PC IN R1
ADI R1, 36  ; CALC RETURN ADDRESS
STR R1, FP  ; PUT PC AT LOCATION FP
RUN R1, FIB ; START NEW THREAD WITH FIB
BLK
LDR R3, SP
TRP 1
JMP END





FIB         MOV R3, FP
ADI R3, -8
LDR R3, R3
; IF (N <= 1)
; FP - 8 = LOCATION OF N ON THE STACK
LDR R4, ONE     ; LOAD 1 INTO REGISTER
CMP R3, R4      ; COMPARE N AND 1
BGT R3, FIBELSE ; IF N IS GREATER THAN 1, GO TO ELSE
MOV R7, FP      ; LOAD N INTO R8
ADI R7, -8
LDR R8, R7
JMP FIBRET      ; RETURN TO CALLER
FIBELSE     ; CALL FIB(N-1)
MOV R7, FP      ; LOAD N INTO R8
ADI R7, -8
LDR R8, R7
; TEST FOR OVERFLOW
MOV R5, SP      ; Test for overflow
ADI R5, -12     ; Allocate for 1 int parameters plus RA and PFP
CMP R5, SL
BLT R5, OVERFLOW
; CREATE ACTIVATION RECORD FOR RESET
MOV R3, FP  ; SAVE FOR PFP
MOV FP, SP  ; FP = SP
ADI SP, -4  ; MOVE SP UP TO ADD RA
STR R3, SP  ; PUT PFP AT LOCATION FP - 4
ADI SP, -4  ; MOVE SP TO PASS A INPUT
MOV R3, R8  ; PUT LOCAL N INTO R3
ADI R3, -1  ; SUBTRACT ONE FROM N
STR R3, SP  ; PUT N AT SP (FP - 8)
ADI SP, -4  ; MOVE SP UP TO LEAVE ROOM FOR RETURN VALUE (FP - 12)
MOV R1, PC  ; PUT PC IN R1
ADI R1, 36  ; CALC RETURN ADDRESS
STR R1, FP  ; PUT PC AT LOCATION FP
JMP FIB     ; JUMP TO FIB
; GET RETURN VALUE AND PUT IT INTO R3
LDR R3, SP
; TEST FOR OVERFLOW
MOV R5, SP      ; Test for overflow
ADI R5, -4     ; Allocate for 1 TEMP VARIABLE
CMP R5, SL
BLT R5, OVERFLOW
ADI SP, -4   ; ALLOCATE ROOM FOR LOCAL VARIABLE ON STACK, LEAVE RETURN VALUE IN SPOT
; CALL FIB(N-2)
MOV R7, FP      ; LOAD N INTO R8
ADI R7, -8
LDR R8, R7
; TEST FOR OVERFLOW
MOV R5, SP      ; Test for overflow
ADI R5, -12     ; Allocate for 1 int parameters plus RA and PFP
CMP R5, SL
BLT R5, OVERFLOW
; CREATE ACTIVATION RECORD FOR FIB
MOV R3, FP  ; SAVE FOR PFP
MOV FP, SP  ; FP = SP
ADI SP, -4  ; MOVE SP UP TO ADD RA
STR R3, SP  ; PUT PFP AT LOCATION FP - 4
ADI SP, -4  ; MOVE SP TO PASS A INPUT
MOV R3, R8  ; PUT LOCAL N INTO R3
ADI R3, -2  ; SUBTRACT 2 FROM N
STR R3, SP  ; PUT N AT SP (FP - 8)
ADI SP, -4  ; MOVE SP UP TO LEAVE ROOM FOR RETURN VALUE (FP - 12)
MOV R1, PC  ; PUT PC IN R1
ADI R1, 36  ; CALC RETURN ADDRESS
STR R1, FP  ; PUT PC AT LOCATION FP
JMP FIB     ; JUMP TO FIB
; GET RETURN VALUE AND PUT IT INTO R3
LDR R3, SP
; ADD FP-12 AND SP
MOV R2, FP
ADI R2, -12
LDR R2, R2
ADD R2, R3
MOV R8, R2

FIBRET      LDR R6, FP      ; RETURN TO CALLER (SAVE RA FOR LATER)
MOV SP, FP      ; BEGIN TO RETURN TO MAIN: SP = FP
MOV R5, SP     ; TEST FOR UNDERFLOW
CMP R5, SB
BGT R5, UNDERFLOW
MOV R1, FP      ; FP = PFP
ADI R1, -4
LDR R2, R1
MOV FP, R2
STR R8, SP      ; PLACE RETURN VALUE ON TOP OF STACK
END



END         LDB R3, NL
TRP 3
TRP 3

