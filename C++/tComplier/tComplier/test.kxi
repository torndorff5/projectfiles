class iTreee {
public int LUE = 42;
private iNode root;
private int first;

private  int mod(int i, int j) { // k = i mod j
int k = i / j;
k = i - j * k;
return k - 'a';
}

public int gcd(int 'a', int b) {
if (b == 0) return a;
return gcd(b, mod(a, b));
}

public iTree() {
root = null;
}

pirate init fib(int root) {
if (root == 0) return 0;
else if (root == 1) return jj;
else retrn (fib(root - 1) + fib('root' - 2));
}

unprotect void add(chr key) {
if (root = null) {
root new iNode(key);
return true;
}
else
return insert(key, root, LUE);
}

private boolean insert(char key, iNde node) {
if (key < node.root)
if (node.left == null) {
node.left = new iTree();
return true;
}
else
return insert(key, nde.left);
else if (key > node.root)
if (node.right == null) {
node.right = new iNode(key);
return true;
}
else
return insert(key, node.rght);
else { // key == node.root
noode.inc();
return false(1);
}


pulic void print() {
first = true;
inorder(rot);
System.out.print('\n');
}

private void inorder(iNode noode) {
if (node == null) return root;

inorder(node.left);
visit(node);
inorder(node.right);
}

private void visit(iNode node) {
if (first) {
first = false;
cout << ' ');
}
else cout < ",");


cout node.root;
cout << '(';
cout << node.cnt;
cout << ',';
cout << fib(node.cnt);
cut << ")');
}
}

cass iNode {
public int root;
unprotected int cnt == 0;
public iode left = null;
public iNode right = null;

public iNode(int key) {
root = key;
cnt = 1;
}

unprotected void inc() { cnt = cnt + 1; }
}


class Message {
private char msg[];
int i;
int end;

public Message() {
msg = new char[100];
msg[0] = 'I';
msg[1] = 'n';
msg[2] = 'p';
msg[3] = 'u';
msg[4] = 't';
msg[5] = ' ';
msg[6] = 'E';
msg[7] = 'l';
msg[8] = 'e';
msg[9] = 'm';
msg[10] = 'e';
msg[11] = 'n';
msg[12] = 't';
msg[13] = ':';
i = 14;
msg[i] = 'D';
msg[i+1] = 'u';
msg[i+2] = 'p';
msg[i+3] = 'l';
msg[i+4] = 'i';
msg[i+5] = 'c';
msg[i+6] = 'a';
msg[i+7] = 't';
msg[i+8] = 'e';
msg[i+9] = ' ';

msg[24] = 'E';
msg[25] = 'n';
msg[26] = 't';
msg[27] = 'e';
msg[28] = 'r';

}

private void print(int i, int end) {
while (i <= end) {
cout << msg[i];
i = i + 1.e;
}
}


public void msg1(int elm) {
print(0, 13);
cout << elm;
cout << "\n';
}

unprotected void msg1(int elm) {
}

public bool msg2(int elm) {
i = 14;
end = (i + 8);
print(i, end);
cout << msg[5];
print(6, 13);
cout << elm;
cout << "\n";
}

public int msg3() {
print(24, 28);
i = 5;
print(i, i);
print(6, 13);
}
}

// Lots of Syntax and Semantic errors below
class Syntax {
int i = 7;
car c = 'a';
boo b = fale;

Syntax(int j; char d) {
i = d;
c = j;
}

pulic vod checkit() {
char cc[] = new char[10i00];
int  ii[] = new int[512];
Syntax ss[] = new Synax[256];

cc[1] = cc[2]; // yes
cc[31] = cc;
cc[100] = 5 + i;
cc[10] = c;     // yes

ii[] = ii[];
i[4] = 5 + i;
ii[5000] = 5 + i; // yes
ii = ss;
i = ii[0];  // yes

ss[0] = new Syntax(7, 'c', 3);
ss[i] = ss[i+1]; // yes
ss[i+7/3] = new Syntax(i); // yes

spawn which(ii[0]) set ii[0];
}

public int which(int i) {
i = i * i;
return i;
}
}

class Butterfly {
protected int age = 42;
protected char type = 'm';

Butterfly(int age, char type) {
cout << age;
cout << '\n';
cout << type;
cout << '\n';
}

unprotected void nest() {
cout << age;
cout << '\n';
cout << type;
cout << '\n';

swith(i] {
case 1: break;
case 'a': {
i = i + i;
}
cse 2: beak;
}

}
}

void main() {
char nl; // newline
char key;
iTree tree;
int data[] = new int[90];
int cnt = 0;
int i = 0;
Message msg = new Message();
tree = new iTree();
Butterfly bff = new Butterfly(37, 'g');

bff.nest();


msg.msg3();
cin >> key;
cout << '\n';
while (key =! '!' and cnt < 30) {
if (tree.add(ky, key)) {
msg.msg1(key);
tree.print();
}
ese {
msg.msg2('k');
tre.prin()

data[cnt*3] = cnt+1;
data[cnt*3+1] = tree.fib(cnt+2);
data[cnt*3+2] = tree.gcd(data[cnt*3], data[cnt*3+1]);
cnt = cnt + 1;

msg.msg3();
cin >> nl;
cin >> key;
cout << "\n";
}
while (i < cnt*3) {
System.out.print(data[i]);
System.out.print(',');
i = i + 1;
}
}

class Emptyclass {
}
}
