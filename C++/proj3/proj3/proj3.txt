SIZE .INT 7
CNT .INT 0
TENTH .INT 0
ZERO .INT 0
ONE .INT 1
NILL .BYT 48
C .BYT 'H'
.BYT 'E'
.BYT 'L'
.BYT 'L'
.BYT 'O'
.BYT 'W'
.BYT 10
DATA .INT 0
FLAG .INT 0
OPDV .INT 0
A .BYT 'A'
B .BYT 'B'
c .BYT 'C'
D .BYT 'D'
E .BYT 'E'
F .BYT 'F'
G .BYT 'G'
H .BYT 'H'
I .BYT 'I'
J .BYT 'K'
L .BYT 'L'
M .BYT 'M'
N .BYT 'N'
O .BYT 'O'
P .BYT 'P'
R .BYT 'R'
S .BYT 'S'
T .BYT 'T'
U .BYT 'U'
V .BYT 'V'
W .BYT 'W'
Y .BYT 'Y'
NL .BYT 10
SE .BYT 32
STOP .BYT '@'
PLUS .BYT '+'
MIN .BYT '-'


MAIN       ; Call reset function
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -20     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREATE ACTIVATION RECORD FOR RESET
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            ADI SP, -4  ; MOVE SP TO PASS A 1
            LDR R3, ONE
            STR R3, SP  ; PUT 1 AT FP - 8
            ADI SP, -4  ; MOVE SP TO PASS A 0
            LDR R3, ZERO
            STR R3, SP  ; PUT 0 AT FP - 12
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 16
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 20
            MOV R1, PC  ; PUT PC IN R1
            ADI R1, 36  ; CALC RETURN ADDRESS
            STR R1, FP  ; PUT PC AT LOCATION FP
            JMP RESET   ; JUMP TO RESET
            ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
WHILEM      LDB R1, C
            LDB R2, STOP
            CMP R1, R2
            BRZ R1, ENDWHILEM
            ; CONTENTS OF MAIN WHILE LOOP
            ;   IF C[0] == + || -
            LDB R1, C
            LDB R2, PLUS
            CMP R1, R2
            BRZ R1, IFM
            LDB R1, C
            LDB R2, MIN
            CMP R1, R2
            BRZ R1, IFM
            ; ELSE STATMENT
            LDB R1, C       ; C[1] = C[0]
            LDA R2, C
            ADI R2, 1
            STB R1, R2      ; STORE CONTENTS OF R1 (C[0]) INTO THE ADDRESS AT R2 C[1]
            LDA R1, C       ; C[0] = +
            LDB R2, PLUS
            STB R2, R1
            LDR R2, CNT     ; INCREMENT CNT
            ADI R2, 1
            STR R2, CNT
            JMP WHILEMM
IFM         ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
WHILEMM     ; IF C[CNT-1] == NL
            LDA R1, C
            LDR R2, CNT
            ADI R2, -1
            ADD R1, R2
            LDB R2, R1
            LDB R1, NL
            CMP R1, R2
            BNZ R1, ELSEMM

ELSEMM      ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
            JMP WHILEMM
ENDWHILEMM  ; Call reset function
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -20     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREATE ACTIVATION RECORD FOR RESET
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            ADI SP, -4  ; MOVE SP TO PASS A 1
            LDR R3, ONE
            STR R3, SP  ; PUT 1 AT FP - 8
            ADI SP, -4  ; MOVE SP TO PASS A 0
            LDR R3, ZERO
            STR R3, SP  ; PUT 0 AT FP - 12
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 16
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 20
            MOV R1, PC  ; PUT PC IN R1
            ADI R1, 36  ; CALC RETURN ADDRESS
            STR R1, FP  ; PUT PC AT LOCATION FP
            JMP RESET   ; JUMP TO RESET
            ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
            JMP WHILEM
ENDWHILEM   JMP END

OPD         ; 3 variables char s, int k, char j
RESET       ; DECLARE INT K
            MOV R5, SP      ; TEST FOR OVERFLOW
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ADI SP, -4      ; ALLOCATE SPACE ON FP FOR INT K
            LDR R3, ZERO
            STR R3, SP
FORR        LDR R5, SP
            LDR R4, SIZE    ; COMPARE K WITH SIZE
            CMP R5, R4
            BRZ R5, ENDFORR
            LDA R2, C
            LDR R1, SP
            ADD R2, R1      ; ADD K WITH ADDRESS OF C
            LDB R3, NILL
            STB R3, R2      ; ASSIGN CONTENTS OF R2 TO '0'
            LDB R3, R2      ; DEBUG OUT PUT  ********************************
            TRP 3
            ADI R1, 1       ; INCREMENT K
            STR R1, SP
            JMP FORR
ENDFORR     MOV R1, FP      ; ASSIGN DATA TO W
            ADI R1, -8
            LDR R2, DATA
            STR R1, R2
            MOV R1, FP      ; ASSIGN OPDV TO X
            ADI R1, -12
            LDR R2, OPDV
            STR R1, R2
            MOV R1, FP      ; ASSIGN CNT TO Y
            ADI R1, -16
            LDR R2, CNT
            STR R1, R2
            MOV R1, FP      ; ASSIGN FLAG TO Z
            ADI R1, -20
            LDR R2, FLAG
            STR R1, R2
            LDB R3, NL      ; DEBUG OUTPUT ********************************
            TRP 3
            MOV SP, FP      ; SP = FP
            MOV R5, SP     ; TEST FOR UNDERFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO MAIN
            JMR R5

GETDATA     LDR CNT, R5     ; if cnt < size
            LDR SIZE, R4
            CMP R5, R4
            BLT R5, IFGD
            JMP ELSEGD
IFGD        TRP 4           ; C[CNT] = GETCHAR()
            LDA R1, C
            LDR R2, CNT
            ADD R1, R2
            STB R3, R1
            LDR R2, CNT
            ADI R2, 1       ; INCREMENT CNT
            STR R2, CNT
            JMP ENDGD
ELSEGD      LDB R3, N       ; PRINT "NUMBER TOO BIG\N"
            TRP 3
            LDB R3, U
            TRP 3
            LDB R3, M
            TRP 3
            LDB R3, B
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, R
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, T
            TRP 3
            LDB R3, O
            TRP 3
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, B
            TRP 3
            LDB R3, I
            TRP 3
            LDB R3, G
            TRP 3
            LDB R3, NL
            TRP 3
            ; CALL FLUSH
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -4     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; PREPARE ACTIVATION RECORD
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC  ; PUT PC IN R1
            ADI R1, 36  ; CALC RETURN ADDRESS
            STR R1, FP  ; PUT PC AT LOCATION FP
            JMP FLUSH   ; JUMP TO FLUSH
            ;
ENDGD       MOV SP, FP      ; SP = FP
            MOV R5, SP      ; TEST FOR UNDEFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO CALL
            JMR R5

FLUSH       LDR R1, ZERO    ; SET DATA TO 0
            STR R1, DATA
            LDA R1, C       ; C[0] = GETCHAR()
            TRP 4
            STB R3, R1
WHILEF      LDB R1, C
            LDB R2, NL
            CMP R1, R2
            BRZ R1, ENDWHILEF
            LDA R1, C
            TRP 4
            STB R3, R1
            JMP WHILEF
ENDWHILEF   MOV SP, FP      ; SP = FP
            MOV R5, SP      ; TEST FOR UNDEFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO CALL
            JMR R5


UNDERFLOW   LDB R3, F
            TRP 3
            LDB R3, L
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, W
            TRP 3
            LDB R3, NL
            TRP 3
            TRP 3
            JMP END
OVERFLOW    LDB R3, S
            TRP 3
            LDB R3, T
            TRP 3
            LDB R3, A
            TRP 3
            LDB R3, c
            TRP 3
            LDB R3, K
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, V
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, R
            TRP 3
            LDB R3, F
            TRP 3
            LDB R3, L
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, W
            TRP 3
            LDB R3, NL
            TRP 3
            TRP 3
            JMP END
END         LDB R3, NL
            TRP 3
            TRP 3
