SIZE .INT 7
CNT .INT 0
TENTH .INT 0
TEN .INT 10
ZERO .INT 0
ONE .INT 1
NILL .BYT 48
NEG .INT -1
C .BYT 'H'
.BYT 'E'
.BYT 'L'
.BYT 'L'
.BYT 'O'
.BYT 'W'
.BYT 10
DATA .INT 0
FLAG .INT 0
OPDV .INT 0
ze .BYT '0'
one .BYT '1'
two .BYT '2'
three .BYT '3'
four .BYT '4'
five .BYT '5'
six .BYT '6'
seven .BYT '7'
eight .BYT '8'
nine .BYT '9'
A .BYT 'A'
B .BYT 'B'
c .BYT 'C'
D .BYT 'D'
E .BYT 'E'
F .BYT 'F'
G .BYT 'G'
H .BYT 'H'
I .BYT 'I'
J .BYT 'K'
L .BYT 'L'
M .BYT 'M'
N .BYT 'N'
O .BYT 'O'
P .BYT 'P'
R .BYT 'R'
S .BYT 'S'
T .BYT 'T'
U .BYT 'U'
V .BYT 'V'
W .BYT 'W'
Y .BYT 'Y'
NL .BYT 10
SE .BYT 32
STOP .BYT '@'
PLUS .BYT '+'
MIN .BYT '-'


MAIN       ; Call reset function
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -20     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREATE ACTIVATION RECORD FOR RESET
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            ADI SP, -4  ; MOVE SP TO PASS A 1
            LDR R3, ONE
            STR R3, SP  ; PUT 1 AT FP - 8
            ADI SP, -4  ; MOVE SP TO PASS A 0
            LDR R3, ZERO
            STR R3, SP  ; PUT 0 AT FP - 12
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 16
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 20
            MOV R1, PC  ; PUT PC IN R1
            ADI R1, 36  ; CALC RETURN ADDRESS
            STR R1, FP  ; PUT PC AT LOCATION FP
            JMP RESET   ; JUMP TO RESET
            ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
WHILEM      LDB R1, C
            LDB R2, STOP
            CMP R1, R2
            BRZ R1, ENDWHILEM
            ; CONTENTS OF MAIN WHILE LOOP
            ;   IF C[0] == + || -
            LDB R1, C
            LDB R2, PLUS
            CMP R1, R2
            BRZ R1, IFM
            LDB R1, C
            LDB R2, MIN
            CMP R1, R2
            BRZ R1, IFM
            ; ELSE STATMENT
            LDB R1, C       ; C[1] = C[0]
            LDA R2, C
            ADI R2, 1
            STB R1, R2      ; STORE CONTENTS OF R1 (C[0]) INTO THE ADDRESS AT R2 C[1]
            LDA R1, C       ; C[0] = +
            LDB R2, PLUS
            STB R2, R1
            LDR R2, CNT     ; INCREMENT CNT
            ADI R2, 1
            STR R2, CNT
            JMP WHILEMM
IFM         ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
WHILEMM     LDR R1, DATA    ; data = 1
            LDR R2, ONE
            CMP R1, R2
            BNZ R1, ENDWHILEMM
            ; IF C[CNT-1] == NL
            LDA R1, C
            LDR R2, CNT
            ADI R2, -1
            ADD R1, R2
            LDB R2, R1
            LDB R1, NL
            CMP R1, R2
            BNZ R1, ELSEMM
            LDR R1, ZERO
            STR R1, DATA        ; DATA = 0
            LDR R1, ONE
            STR R1, TENTH       ; TENTH = 1
            LDR R1, CNT
            ADI R1, -2
            STR R1, CNT         ; CNT = CNT - 2
WHILEMMM    LDR R1, FLAG        ; FLAG == 0
            LDR R2, ZERO
            CMP R1, R2
            BNZ R1, ENDWHILEMMM
            LDR R1, CNT
            CMP R1, R2
            BRZ R1, ENDWHILEMMM
            ; call opd(c[0], tenth, c[cnt])
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -16     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREATE ACTIVATION RECORD FOR RESET
            MOV R3, FP        ; SAVE FOR PFP
            MOV FP, SP       ; FP = SP
            ADI SP, -4        ; MOVE SP UP TO ADD RA
            STR R3, SP        ; PUT PFP AT LOCATION FP - 4
            ADI SP, -4        ; MOVE SP TO PASS c[0]
            LDB R3, C
            STB R3, SP        ; PUT C[0] AT FP - 8
            ADI SP, -4       ; MOVE SP TO PASS TENTH
            LDR R3, TENTH
            STR R3, SP        ; PUT TENTH AT FP - 12
            ADI SP, -4       ; MOVE SP TO PASS A 0
            LDA R3, C
            ADD R3, CNT
            LDB R2, R3
            STB R2, SP       ; PUT C[CNT] AT FP - 16
            MOV R1, PC      ; PUT PC IN R1
            ADI R1, 36      ; CALC RETURN ADDRESS
            STR R1, FP      ; PUT PC AT LOCATION FP
            JMP OPD   ; JUMP TO OPD
            LDR R1, CNT     ; cnt--
            ADI R1, -1
            STR R1, CNT
            LDR R1, TENTH   ; tenth *= 10
            LDR R2, TEN
            MUL R1, R2
            STR R1, TENTH
            JUMP WHILEMMM
ENDWHILEMMM LDR R1, FLAG
            LDR R2, ZERO
            CMP R1, R2
            BNZ R1, ENDIFMMM
            LDB R3, O
            TRP 3
            LDB R3, P
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, R
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, A
            TRP 3
            LDB R3, N
            TRP 3
            LDB R3, D
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, I
            TRP 3
            LDB R3, S
            TRP 3
            LDB R3, SE
            TRP 3
            LDR R3, OPDV
            TRP 1
            LDB R3, NL
            TRP 3
ENDIFMMM    JMP ENDWHILEMM
ELSEMM      ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
            JMP WHILEMM
ENDWHILEMM  ; Call reset function
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -20     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREATE ACTIVATION RECORD FOR RESET
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            ADI SP, -4  ; MOVE SP TO PASS A 1
            LDR R3, ONE
            STR R3, SP  ; PUT 1 AT FP - 8
            ADI SP, -4  ; MOVE SP TO PASS A 0
            LDR R3, ZERO
            STR R3, SP  ; PUT 0 AT FP - 12
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 16
            ADI SP, -4  ; MOVE SP TO PASS A 0
            STR R3, SP  ; PUT 0 AT FP - 20
            MOV R1, PC  ; PUT PC IN R1
            ADI R1, 36  ; CALC RETURN ADDRESS
            STR R1, FP  ; PUT PC AT LOCATION FP
            JMP RESET   ; JUMP TO RESET
            ; CALL GETDATA()
            ; TEST FOR OVERFLOW
            MOV R5, SP
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ; CREAT ACTIVATION RECORD FOR GETDATA()
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC
            ADI R1, 36
            STR R1, FP
            JMP GETDATA
            JMP WHILEM
ENDWHILEM   JMP END

RESET       ; DECLARE INT K
            MOV R5, SP      ; TEST FOR OVERFLOW
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ADI SP, -4      ; ALLOCATE SPACE ON FP FOR INT K
            LDR R3, ZERO
            STR R3, SP
FORR        LDR R5, SP
            LDR R4, SIZE    ; COMPARE K WITH SIZE
            CMP R5, R4
            BLT R5, IFFORR
            JMP ENDFORR
IFFORR      LDA R2, C
            LDR R1, SP
            ADD R2, R1      ; ADD K WITH ADDRESS OF C
            LDB R3, NILL
            STB R3, R2      ; ASSIGN CONTENTS OF R2 TO '0'
            ADI R1, 1       ; INCREMENT K
            STR R1, SP
            JMP FORR
ENDFORR     MOV R1, FP      ; ASSIGN DATA TO W
            ADI R1, -8
            LDR R2, DATA
            STR R1, R2
            MOV R1, FP      ; ASSIGN OPDV TO X
            ADI R1, -12
            LDR R2, OPDV
            STR R1, R2
            MOV R1, FP      ; ASSIGN CNT TO Y
            ADI R1, -16
            LDR R2, CNT
            STR R1, R2
            MOV R1, FP      ; ASSIGN FLAG TO Z
            ADI R1, -20
            LDR R2, FLAG
            STR R1, R2
            MOV SP, FP      ; SP = FP
            MOV R5, SP     ; TEST FOR UNDERFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO MAIN
            JMR R5

GETDATA     LDR R5, CNT     ; if cnt < size
            LDR R4, SIZE
            CMP R5, R4
            BLT R5, IFGD
            JMP ELSEGD
IFGD        TRP 4           ; C[CNT] = GETCHAR()
            LDA R1, C
            LDR R2, CNT
            ADD R1, R2
            STB R3, R1
            LDR R2, CNT
            ADI R2, 1       ; INCREMENT CNT
            STR R2, CNT
            JMP ENDGD
ELSEGD      LDB R3, N       ; PRINT "NUMBER TOO BIG\N"
            TRP 3
            LDB R3, U
            TRP 3
            LDB R3, M
            TRP 3
            LDB R3, B
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, R
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, T
            TRP 3
            LDB R3, O
            TRP 3
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, B
            TRP 3
            LDB R3, I
            TRP 3
            LDB R3, G
            TRP 3
            LDB R3, NL
            TRP 3
            ; CALL FLUSH
            ; TEST FOR OVERFLOW
            MOV R5, SP      ; Test for overflow
            ADI R5, -4     ; Allocate for 4 int parameters plus RA and PFP
            CMP R5, SL
            BLT R5, OVERFLOW
            ; PREPARE ACTIVATION RECORD
            MOV R3, FP  ; SAVE FOR PFP
            MOV FP, SP  ; FP = SP
            ADI SP, -4  ; MOVE SP UP TO ADD RA
            STR R3, SP  ; PUT PFP AT LOCATION FP - 4
            MOV R1, PC  ; PUT PC IN R1
            ADI R1, 36  ; CALC RETURN ADDRESS
            STR R1, FP  ; PUT PC AT LOCATION FP
            JMP FLUSH   ; JUMP TO FLUSH
            ;
ENDGD       MOV SP, FP      ; SP = FP
            MOV R5, SP      ; TEST FOR UNDEFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO CALL
            JMR R5

FLUSH       LDR R1, ZERO    ; SET DATA TO 0
            STR R1, DATA
            LDA R1, C       ; C[0] = GETCHAR()
            TRP 4
            STB R3, R1
WHILEF      LDB R1, C
            LDB R2, NL
            CMP R1, R2
            BRZ R1, ENDWHILEF
            LDA R1, C
            TRP 4
            STB R3, R1
            JMP WHILEF
ENDWHILEF   MOV SP, FP      ; SP = FP
            MOV R5, SP      ; TEST FOR UNDEFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO CALL
            JMR R5

OPD         ; DECLARE INT T
            MOV R5, SP      ; TEST FOR OVERFLOW
            ADI R5, -4
            CMP R5, SL
            BLT R5, OVERFLOW
            ADI SP, -4      ; ALLOCATE SPACE ON FP FOR INT T
            LDR R3, ZERO
            STR R3, SP
            MOV R1, FP      ; SEE IF J == '0'
            ADI R1, -16     ; GET TO J
            LDB R2, R1      ; PUT J IN R2
            LDB R3, ze
            CMP R2, R3
            BNZ R2, EI1
            JMP ENDEI
EI1         LDB R2, R1
            LDB R3, one
            CMP R2, R3
            BNZ R2, EI2
            LDR R5, SP      ; T = 1
            ADI R5, 1
            STR R5, SP
            JMP ENDEI
EI2         LDB R2, R1
            LDB R3, two
            CMP R2, R3
            BNZ R2, EI3
            LDR R5, SP      ; T = 2
            ADI R5, 2
            STR R5, SP
            JMP ENDEI
EI3         LDB R2, R1
            LDB R3, three
            CMP R2, R3
            BNZ R2, EI4
            LDR R5, SP      ; T = 3
            ADI R5, 3
            STR R5, SP
            JMP ENDEI
EI4         LDB R2, R1
            LDB R3, four
            CMP R2, R3
            BNZ R2, EI5
            LDR R5, SP      ; T = 4
            ADI R5, 4
            STR R5, SP
            JMP ENDEI
EI5         LDB R2, R1
            LDB R3, five
            CMP R2, R3
            BNZ R2, EI6
            LDR R5, SP      ; T = 5
            ADI R5, 5
            STR R5, SP
            JMP ENDEI
EI6         LDB R2, R1
            LDB R3, six
            CMP R2, R3
            BNZ R2, EI7
            LDR R5, SP      ; T = 6
            ADI R5, 6
            STR R5, SP
            JMP ENDEI
EI7         LDB R2, R1
            LDB R3, seven
            CMP R2, R3
            BNZ R2, EI8
            LDR R5, SP      ; T = 7
            ADI R5, 7
            STR R5, SP
            JMP ENDEI
EI8         LDB R2, R1
            LDB R3, eight
            CMP R2, R3
            BNZ R2, EI9
            LDR R5, SP      ; T = 8
            ADI R5, 8
            STR R5, SP
            JMP ENDEI
EI9         LDB R2, R1
            LDB R3, nine
            CMP R2, R3
            BNZ R2, EI10
            LDR R5, SP      ; T = 9
            ADI R5, 9
            STR R5, SP
            JMP ENDEI
EI10        LDB R3, R1       ; "c is not a number\n"
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, I
            TRP 3
            LDB R3, S
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, N
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, T
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, A
            TRP 3
            LDB R3, SE
            TRP 3
            LDB R3, N
            TRP 3
            LDB R3, U
            TRP 3
            LDB R3, M
            TRP 3
            LDB R3, B
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, R
            TRP 3
            LDB R3, NL
            TRP 3
ENDEI       LDR R1, FLAG
            LDR R2, ZERO
            CMP R1, R2
            BNZ R1, ENDII        ; IF FLAG == 0
            MOV R1, FP
            ADI R1, -8
            LDB R2, R1            ; GET S OUT FROM FP - 8
            LDB R3, PLUS
            CMP R2, R3
            BNZ R2, ENDSIGN
            LDR R5, SP
            MOV R6, FP
            ADI R6, -12
            LDR R7, R6
            MUL R5, R7
            JMP ENDII
ENDSIGN     LDR R5, SP
            MOV R6, FP
            ADI R6, -12
            LDR R7, R6
            LDR R3, NEG
            MUL R7, R3      ; MULTIPLY K BY -1
            MUL R5, R7      ; MULTIPLY T BY K
ENDII       LDR R1, OPDV
            LDR R2, SP
            ADD R1, R2
            MOV SP, FP      ; SP = FP
            MOV R5, SP      ; TEST FOR UNDEFLOW
            CMP R5, SB
            BGT R5, UNDERFLOW
            MOV R1, FP      ; FP = PFP
            ADI R1, -4
            LDR R2, R1
            MOV FP, R2
            LDR R5, FP      ; RETURN TO CALL
            JMR R5

UNDERFLOW   LDB R3, F
            TRP 3
            LDB R3, L
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, W
            TRP 3
            LDB R3, NL
            TRP 3
            TRP 3
            JMP END
OVERFLOW    LDB R3, S
            TRP 3
            LDB R3, T
            TRP 3
            LDB R3, A
            TRP 3
            LDB R3, c
            TRP 3
            LDB R3, K
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, V
            TRP 3
            LDB R3, E
            TRP 3
            LDB R3, R
            TRP 3
            LDB R3, F
            TRP 3
            LDB R3, L
            TRP 3
            LDB R3, O
            TRP 3
            LDB R3, W
            TRP 3
            LDB R3, NL
            TRP 3
            TRP 3
            JMP END
END         LDB R3, NL
            TRP 3
            TRP 3
