00000: Like Smalltalk, Python supports class methods, which differ from static 
00001: methods in that the exact dynamic type of the object being operated on is 
00002: an implicit parameter to the method (as a type object).  The following 
00003: example keeps a separate per-class object counter for every class in a 
00004: hierarchy (in this case, a Shape hierarchy): 
00005: 
00006: class Shape(object):
00007:     _count = 0	# A shared value for Shape classes with no current objects
00008:   	
00009:     @classmethod
00010:     def _incr(cls):
00011:         cls._count += 1         # Create/update class attribute
00012:       
00013:     @classmethod
00014:     def showCount(cls):
00015:         print 'Class %s has count = %s' % (cls.__name__, cls._count)
00016:         
00017:     def __init__(self):		# A constructor
00018:         self._incr()
00019: 
00020: class Point(Shape): pass	# An empty subclass of Shape
00021: class Line(Shape): pass		# Ditto
00022: 
00023: This requires some perusing if you're new to Python.  Python requires 
00024: indentation to show logical subordination (whereas good programmers of 
00025: other languages indent by convention), so you can readily see that the 
00026: class Shape has three methods, _incr, showCount, and __init__.  The latter 
00027: is the special name used for constructors.  The other two methods are 
00028: class methods (indicated by the @classmethod prefix), so their parameter 
00029: is the unique class object for the instance on which they are invoked.  
00030: (The term "class object" here refers to a unique, bona fide object that 
00031: describes a class type, similar to, but more robust than, std::type_info 
00032: objects in C++.) The method named _incr is only called by the constructor.  
00033: 
